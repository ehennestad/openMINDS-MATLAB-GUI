<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Searchable Dropdown</title>

<style>
  :root {
    --radius-pill: 999px;
    --radius-card: 10px;
  }

  /* Light theme colors */
  :root,
  body[data-theme="light"] {
    --border-color: #d0d7e2;
    --border-color-focus: #4c8dff;
    --bg-control: #f6f7fb;
    --bg-panel: #ffffff;
    --text-color: #111827;
    --placeholder-color: #9ca3af;
    --muted: #6b7280;
    --shadow-soft: 0 1px 2px rgba(15, 23, 42, 0.08);
    --option-hover: #eef2ff;
    --option-selected: #e0ebff;
    --option-highlighted: #dbeafe;
    --option-highlighted-border: #bfdbfe;
    --options-border: #e5e7eb;
  }

  /* Dark theme colors - MATLAB style */
  body[data-theme="dark"] {
    --border-color: #3d3d3d;
    --border-color-focus: #1f8ded;
    --bg-control: #2d2d2d;
    --bg-panel: #1e1e1e;
    --text-color: #d4d4d4;
    --placeholder-color: #858585;
    --muted: #9d9d9d;
    --shadow-soft: 0 1px 2px rgba(0, 0, 0, 0.5);
    --option-hover: #383838;
    --option-selected: #094771;
    --option-highlighted: #0e639c;
    --option-highlighted-border: #1f8ded;
    --options-border: #3d3d3d;
  }

  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: var(--bg-panel);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  /* Root frame fills the uihtml area and has a border */
  .uihtml-frame {
    position: absolute;
    inset: 0;
    box-sizing: border-box;
    border: 1px solid var(--border-color);
    border-radius: var(--radius-card);
    display: flex;
    flex-direction: column;
    padding: 4px;
    background: var(--bg-panel);
    outline: none;
  }

  /* The only input: search / current value */
  .search-input {
    box-sizing: border-box;
    width: 100%;
    padding: 5px 10px;
    border-radius: var(--radius-pill);
    border: 1px solid var(--border-color);
    background: var(--bg-control);
    color: var(--text-color);
    font-size: 11px;
    outline: none;
    box-shadow: var(--shadow-soft);
    transition:
      border-color 120ms ease,
      box-shadow 120ms ease,
      background 120ms ease;
  }

  .search-input::placeholder {
    color: var(--placeholder-color);
  }

  .search-input:focus {
    border-color: var(--border-color-focus);
    background: var(--bg-panel);
    box-shadow:
      0 0 0 1px var(--border-color-focus),
      var(--shadow-soft);
  }

  /* Options list: always visible, scrolls inside frame */
  .options-scroll {
    box-sizing: border-box;
    margin-top: 4px;
    flex: 1 1 auto;
    overflow-y: auto;
    padding-right: 2px;
    border-radius: 8px;
    background: var(--bg-panel);
    box-shadow: inset 0 0 0 1px var(--options-border);
  }

  .option-item {
    font-size: 12px;
    padding: 4px 6px;
    border-radius: 6px;
    cursor: pointer;
    color: var(--text-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .option-item:hover {
    background: var(--option-hover);
  }

  .option-item.selected {
    background: var(--option-selected);
    font-weight: 500;
  }

  .option-item.highlighted {
    background: var(--option-highlighted);
    outline: 1px solid var(--option-highlighted-border);
  }

  .no-results {
    font-size: 11px;
    color: var(--muted);
    padding: 4px 6px;
  }
</style>

<script type="text/javascript">
  let dropdownState = {
    options: [],
    value: "",
    placeholder: "",
    filter: "",
    highlightedIndex: 0,
    theme: "light"
  };

  function setup(htmlComponent) {
    const searchInput   = document.getElementById("search-input");
    const optionsScroll = document.getElementById("options-scroll");
    const frame         = document.querySelector(".uihtml-frame");

    function applyStateFromData(data) {
      if (Array.isArray(data.options)) {
        dropdownState.options = data.options.slice();
      }
      if (typeof data.value === "string") {
        dropdownState.value  = data.value;
        // If value is empty, also clear the filter
        if (data.value === "") {
          dropdownState.filter = "";
          dropdownState.highlightedIndex = 0;
        } else {
          dropdownState.filter = data.value;
        }
        searchInput.value = dropdownState.filter;
      }
      if (typeof data.placeholder === "string") {
        dropdownState.placeholder = data.placeholder;
      }
      if (typeof data.theme === "string") {
        dropdownState.theme = data.theme;
        document.body.setAttribute("data-theme", data.theme);
      }

      searchInput.placeholder =
        dropdownState.placeholder || "Search or select…";

      render();
    }

    function handleCommand(data) {
      if (!data || typeof data.command !== "string") {
        return false;
      }

      if (data.command === "focus") {
        setTimeout(() => {
          searchInput.focus();
          searchInput.select();
        }, 30);
        return false;
      }
      
      if (data.command === "reset") {
        // Update options if provided
        if (Array.isArray(data.options)) {
          dropdownState.options = data.options.slice();
        }
        
        // Clear all state
        dropdownState.value = "";
        dropdownState.filter = "";
        dropdownState.highlightedIndex = 0;
        searchInput.value = "";
        searchInput.blur();
        
        // Update placeholder if provided
        if (typeof data.placeholder === "string") {
          dropdownState.placeholder = data.placeholder;
          searchInput.placeholder = dropdownState.placeholder || "Search or select…";
        }
        
        render();
        return true;  // Block normal state update
      }
      
      return false;
    }

    function getFilteredOptions() {
      const filter = dropdownState.filter.toLowerCase();
      return dropdownState.options.filter(opt =>
        String(opt).toLowerCase().includes(filter)
      );
    }

    function clampHighlighted(filtered) {
      if (filtered.length === 0) {
        dropdownState.highlightedIndex = 0;
        return;
      }
      if (
        dropdownState.highlightedIndex < 0 ||
        dropdownState.highlightedIndex >= filtered.length
      ) {
        dropdownState.highlightedIndex = 0;
      }
    }

    function render() {
      const filtered = getFilteredOptions();
      clampHighlighted(filtered);

      optionsScroll.innerHTML = "";

      if (filtered.length === 0) {
        const div = document.createElement("div");
        div.className = "no-results";
        div.textContent = "No matches";
        optionsScroll.appendChild(div);
        return;
      }

      filtered.forEach((opt, idx) => {
        const div = document.createElement("div");
        div.className = "option-item";
        div.textContent = String(opt);

        if (String(opt) === dropdownState.value) {
          div.classList.add("selected");
        }
        if (idx === dropdownState.highlightedIndex) {
          div.classList.add("highlighted");
        }

        div.addEventListener("click", () => {
          selectValue(String(opt), /*closeAndAccept=*/true);
        });

        optionsScroll.appendChild(div);
      });
    }

    function ensureHighlightedVisible() {
      const highlightedNode =
        optionsScroll.querySelector(".option-item.highlighted");
      if (!highlightedNode) {
        return;
      }
      const top = highlightedNode.offsetTop;
      const bottom = top + highlightedNode.offsetHeight;
      const viewTop = optionsScroll.scrollTop;
      const viewBottom = viewTop + optionsScroll.clientHeight;
      if (top < viewTop) {
        optionsScroll.scrollTop = top;
      } else if (bottom > viewBottom) {
        optionsScroll.scrollTop = bottom - optionsScroll.clientHeight;
      }
    }

    function selectValue(val, closeAndAccept) {
      dropdownState.value  = val;
      dropdownState.filter = val;
      searchInput.value    = val;
      render();

      htmlComponent.Data = {
        value: dropdownState.value,
        action: closeAndAccept ? "accept" : "select"
      };
      
      if (closeAndAccept) {
        searchInput.blur();
      }
    }

    function moveHighlight(delta) {
      const filtered = getFilteredOptions();
      if (filtered.length === 0) {
        return;
      }
      dropdownState.highlightedIndex += delta;
      if (dropdownState.highlightedIndex < 0) {
        dropdownState.highlightedIndex = filtered.length - 1;
      } else if (dropdownState.highlightedIndex >= filtered.length) {
        dropdownState.highlightedIndex = 0;
      }
      render();
      ensureHighlightedVisible();
    }

    function selectHighlightedAndAccept() {
      const filtered = getFilteredOptions();
      if (filtered.length === 0) {
        return;
      }
      const idx = dropdownState.highlightedIndex;
      const val = String(filtered[idx]);
      selectValue(val, /*closeAndAccept=*/true);
    }

    // Search field: text change
    searchInput.addEventListener("input", () => {
      dropdownState.filter = searchInput.value;
      if (searchInput.value === "") {
        dropdownState.value = "";
      }
      dropdownState.highlightedIndex = 0;
      render();
    });

    // Keyboard handler function (shared between input and global)
    function handleKeydown(evt) {
      if (evt.key === "ArrowDown") {
        evt.preventDefault();
        moveHighlight(1);
      } else if (evt.key === "ArrowUp") {
        evt.preventDefault();
        moveHighlight(-1);
      } else if (evt.key === "Enter") {
        // Enter: select highlighted and close
        evt.preventDefault();
        selectHighlightedAndAccept();
      } else if (evt.key === "Escape" || evt.key === " ") {
        // Escape or Space: cancel and close
        evt.preventDefault();
        htmlComponent.Data = {
          value: dropdownState.value,
          action: "cancel"
        };
        searchInput.blur();
      }
    }

    // Search field: keyboard navigation + accept/cancel
    searchInput.addEventListener("keydown", handleKeydown);

    // Global keyboard handler for the entire component
    document.addEventListener("keydown", evt => {
      // Only handle if focus is somewhere in the component
      // and not already in the input (to avoid double handling)
      if (document.activeElement !== searchInput) {
        handleKeydown(evt);
      }
    });

    // Make the frame focusable and focus it on click
    frame.setAttribute("tabindex", "0");
    optionsScroll.addEventListener("click", () => {
      frame.focus();
    });

    // Initial state and event listener setup
    const initialData = htmlComponent.Data || {};
    applyStateFromData(initialData);
    handleCommand(initialData);

    htmlComponent.addEventListener("DataChanged", () => {
      const data = htmlComponent.Data || {};
      // Process commands first; some commands block normal state updates
      if (!handleCommand(data)) {
        applyStateFromData(data);
      }
    });
  }
</script>
</head>

<body>
  <div class="uihtml-frame">
    <input
      id="search-input"
      class="search-input"
      type="text"
      placeholder="Search…"
      autocomplete="off"
    />
    <div id="options-scroll" class="options-scroll"></div>
  </div>
</body>
</html>
